<# Check Clusters for problems during Storage Operations - Checks 5 things:
1) How many VMs are powered on
2) Are any VMs' statuses not normal
3) Are any VMs unpingable
4) Are any VMs's tools not running
5) Checks paths on the cluster(s) you select

To Check Paths:
Simply enter the cluster, clusters, or * then check the check paths and the don't check anything except paths and it'll run a "simple" path check

To use this script:
1) First add your clusters and select SurveyRunOnly
2) Get the info on how many VMs are not pingable, VM count, etc. and put those numbers in the default values below
3) Run the script once without SurveyRunOnly and make sure you DON'T get an e-mail
4) Schedule the cron job by choosing "Build Periodically" below and let the script run automatically every 10 mins - It'll send an e-mail if there is any change to any attribute
#>

$VCPassword = ConvertTo-SecureString "$($ENV:vcpass)" -AsPlainText -Force
$Creds = New-Object System.Management.Automation.PSCredential ("$ENV:vcuser", $vcPassword)

########################################################
#Function to run a fast ping against a bunch of systems#
########################################################
function Test-OnlineFast
{
    param
    (
        # make parameter pipeline-aware
        [Parameter(Mandatory,ValueFromPipeline)]
        [string[]]
        $ComputerName,

        $TimeoutMillisec = 1000
    )

    begin
    {
        # use this to collect computer names that were sent via pipeline
        [Collections.ArrayList]$bucket = @()
    
        # hash table with error code to text translation
        $StatusCode_ReturnValue = 
        @{
            0='Success'
            11001='Buffer Too Small'
            11002='Destination Net Unreachable'
            11003='Destination Host Unreachable'
            11004='Destination Protocol Unreachable'
            11005='Destination Port Unreachable'
            11006='No Resources'
            11007='Bad Option'
            11008='Hardware Error'
            11009='Packet Too Big'
            11010='Request Timed Out'
            11011='Bad Request'
            11012='Bad Route'
            11013='TimeToLive Expired Transit'
            11014='TimeToLive Expired Reassembly'
            11015='Parameter Problem'
            11016='Source Quench'
            11017='Option Too Big'
            11018='Bad Destination'
            11032='Negotiating IPSEC'
            11050='General Failure'
        }
    
    
        # hash table with calculated property that translates
        # numeric return value into friendly text

        $StatusFriendlyText = @{
            Name = 'Status'
            Expression = {
                if ($_.StatusCode -eq $null) {
                    "Null StatusCode"
                }
                else {
                    $StatusCode_ReturnValue[([int]$_.StatusCode)]
                }
            }
        }

        # calculated property that returns $true when status -eq 0
        $IsOnline = @{
            Name = 'Online'
            Expression = { $_.StatusCode -eq 0 }
        }

        # do DNS resolution when system responds to ping
        $DNSName = @{
            Name = 'DNSName'
            Expression = { if ($_.StatusCode -eq 0) { 
                    if ($_.Address -like '*.*.*.*') 
                    { [Net.DNS]::GetHostByAddress($_.Address).HostName  } 
                    else  
                    { [Net.DNS]::GetHostByName($_.Address).HostName  } 
                }
            }
        }
    }
    
    process
    {
        # add each computer name to the bucket
        # we either receive a string array via parameter, or 
        # the process block runs multiple times when computer
        # names are piped
        $ComputerName | ForEach-Object {
            $null = $bucket.Add($_)
        }
    }
    
    end
    {
        # convert list of computers into a WMI query string
        $query = $bucket -join "' or Address='"
        
        Get-WmiObject -Class Win32_PingStatus -Filter "(Address='$query') and timeout=$TimeoutMillisec" |
        Select-Object -Property Address, $IsOnline, $DNSName, $statusFriendlyText
    }
    
}
################################################################
# End of function to run a fast ping against a bunch of systems#
################################################################4
$bodyofmessage ="Take heed of the following issues below:<br>"
if ($env:DontRunAnyOtherChecksExceptCheckPaths -ne 'true') {
connect-viserver $env:VirtualCenter -credential $creds
$clusters = $env:Clusterlist
$clusters = $clusters.split(',')
$clusters = $clusters.trim()
$vmsnotgreen =$null
$toolsnotrunning =$null
$countofvms = $null
$vmlist = $null

#Create the list of VMs to check on cluster independent#

foreach ($cluster in $clusters) {
$vms = get-cluster $cluster |get-vm |Where-Object {$_.PowerState -eq 'Poweredon' -and $_.name -notlike 'vCLS*'}
$vmlist +=$vms
}


$vmsnotgreen=0
$toolsnotrunning=0
$countofvms=0

write-host "Checking to see if each VM is in a Normal state..."
### Overall Status Start ###
foreach ($vm in $vmlist) {
$overallstatus = get-vm $vm |get-view | select overallstatus |ft -HideTableHeaders |out-string
$overallstatus = $overallstatus.trim()
if ($overallstatus -ne 'green') {Write-host $vm " Is not green"
$vmsnotgreen++
$vmsnotgreenlist += ($vm.name |out-string)
$vmsnotgreenlist += "<br>"
}
}
### Overall Status End ###

write-host "Checking to see if each VM has Tools running or not..."
### Tools Status Start ###
foreach ($vm in $vmlist) {
$guesttoolsrunningstatus = (($vm | get-view).Guest.ToolsRunningStatus)
if ($guesttoolsrunningstatus -ne 'guestToolsRunning') {Write-host $vm " tools is not running"
$toolsnotrunning++
$toolsnotrunninglist += ($vm.name |out-string)
$toolsnotrunninglist += "<br>"
}
}
### Tools Status end ###


write-host "Counting VMs that are powered on..."

### Count of VMs Verification Start ###
$countofvms = $vmlist |Measure-Object -Line |select $lines |ft -HideTableHeaders |out-string
$countofvms = $countofvms.trim()

### Count of VMs Verification End ###

if ($toolsnotrunning -gt $env:toolsnotrunning) {$errorcondition = 1
write-host "VMTools count is wrong"
$bodyofmessage += "Tools not running on the following: <br>"
$bodyofmessage +=  $toolsnotrunninglist
}
if ($countofvms -ne $env:NumberOfVMsToExpect) {$errorcondition = 1
write-host "VM Count is wrong"
$bodyofmessage += "<br>"; $bodyofmessage += "Should be ";$bodyofmessage += ($env:NumberOfVMsToExpect |out-string)
$bodyofmessage += " VMs but there are ";  $bodyofmessage += ($countofvms |out-string) ; $bodyofmessage += "<br>"
}
if ($vmsnotgreen -gt $env:vmsnotgreen) {$errorcondition = 1
write-host "VM Status is wrong on one or more VMs"
$bodyofmessage += "The following VMs are not showing a normal state: <br>"
$bodyofmessage +=  $vmsnotgreenlist
}

write-host "Pinging all the VMs and seeing if anything is not pingable..."
foreach ($vm in $vms) {$vmlist += $vm.name}

$vmsnotPinging =   Test-OnlineFast $vmlist |where-object {$_.status -EQ "Request Timed Out" -and $_.Address -ne 'scrubbedservername'} 
$vmswithbadname = Test-OnlineFast $vmlist |where-object {$_.status -EQ "Null StatusCode" } 
$vmsnotPingingcount = $vmsnotPinging |measure-object |select count -ExpandProperty count
$vmswithbadnamecount = $vmswithbadname |measure-object |select count -ExpandProperty count
if ($vmsnotPingingcount -gt $env:VMsnotpingable) {$errorcondition = 1
Write-host "Some VMs are not pinging"
write-host $vmsnotPinging
$bodyofmessage += "The following VMs are not pinging <br>"
$bodyofmessage += ($vmsnotPinging |out-string)

}


if ($errorcondition -eq 1) {
write-host "Something is not right please check the e-mail for the details in the report"
}

if ($errorcondition -ne 1) {
write-host "Didn't find any issues everything looks good!"
}


disconnect-viserver $env:VirtualCenter -confirm:$False
}

#############################
# If Path Check is Selected #
#############################

if ($env:CheckPaths -eq 'True') {
write-host "Checking paths..."
$targetclusters = $env:clusterlist
$maxthreads = $env:maxthreads
$vcserver = $env:VirtualCenter

$maxthreads = 8

connect-viserver $vcserver -Credential $creds

if ($targetclusters -eq "*"){
    $vmhosts = Get-VMHost | select Name 
}
else {
    $targetclusters = $targetclusters.Split(',')
  $vmhosts = Get-VMHost -Location $targetclusters | select Name

#$vmhosts = Get-VMHost -Location clustername | select Name | sort | select-object -first 1
}

$scriptblock = {
	param($creds,$vcserver,$vmhostname)
	connect-viserver $vcserver -Credential $creds
    $vmhost = get-vmhost $vmhostname
        $vmhost.Name
        $sluns = Get-ScsiLun -VmHost $vmhost | sort CanonicalName
        foreach ($slun in $sluns){
            $deadpath = 0
            $missingpaths = 0
            if ($slun.Vendor -like "3Par*"){
                $slun.RuntimeName
                $slunpaths = Get-ScsiLunPath -ScsiLun $slun
                $slunpaths.count
                if ($slunpaths.count -ne 4){
                    $missingpaths = 1
                }
                foreach ($slunpath in $slunpaths){
                    $slunpath.state.tostring()
                    if ($slunpath.State -eq "Dead"){
                        $deadpath = 1
                    }
                }
                if ($deadpath -eq 1){
                    write-output "Error: $($vmhost.name) - $($slun.CanonicalName)  - Deadpath found on: $($slunpath.Name)"
                }
                if ($missingpaths -eq 1){
                    write-output "Error: $($vmhost.name) - $($slun.RuntimeName) - Pathcount:  $($slunpaths.count)  - Has missing paths."   
                }
            }
        }
    
}	


foreach ($vmhostname in $vmhosts){
	While (@(Get-Job -state running).count -ge $MaxThreads){
		Start-Sleep 1
	}
	$vmhostname = $vmhostname.name
	Write-Host "Starting job for: " $vmhostname

	
	$result = start-job -scriptblock $scriptblock -argumentlist $creds,$vcserver,$vmhostname  | out-null
}

While (Get-Job -State "Running") {
     $running = Get-Job -State "Running"
	write-host "Jobs running: " $running.count
    Start-Sleep 5
}

#Get-Job
write-host "Jobs completed, getting output"    
$results = Get-Job | Receive-Job
Remove-Job *

$results
if ($results -like "Error:*"){
$errorcondition =1
$bodyofmessage += "There were dead paths found youll need to look at the Jenkins console output to see which and how many"
    foreach ($result in $results){
        if ($result -like "Error:*"){
            $result
        }
    }
}
else {
    Write-Output "No Dead or Missing paths were found."
}
disconnect-viserver $env:VirtualCenter -confirm:$False
}

if ($env:SurveyRunOnly -eq 'true') {
write-host "Survey Results: "
write-host "Tools not running: " $toolsnotrunning
write-host "Count of VMs: " $countofvms
write-host "VMs not Green: " $vmsnotgreen
write-host "VMs not Pingable: " $vmsnotPingingcount
}


if ($env:SurveyRunOnly -ne 'true' -and $env:DontRunAnyOtherChecksExceptCheckPaths -ne 'true') {
write-host "powered on VMs were " $env:NumberOfVMsToExpect " before on devvcenter, they are now: " $countofvms
write-host "VMs not Green expected: " $env:vmsnotgreen "VMs not Green Actual: " $vmsnotgreen
write-host "Tools not running expected: " $env:toolsnotrunning "Tools not running Actual: " $toolsnotrunning
write-host "VMs not pinging should be " $env:VMsnotpingable " And is actually: " $vmsnotPingingcount
write-host "VMs that have weird unpingable names: " $vmswithbadnamecount

if ($errorcondition -eq 1) {
$emaillist = $env:whotoemail.split(',')
foreach ($recipient in $emaillist) {

Send-MailMessage -From “email@domain.com” -To $recipient -Subject "Cluster Monitor Issues " -BodyasHTML $bodyofmessage -SmtpServer mail.domain.com 
}

}
}
